<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner.html">

<dom-module id="twb-chart">
  <style>
    :host {
      display: inline-block;
    }

    #canvas {
      width: 100%;
      height: 100%;
      position:relative;
    }

    #loading {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #999;
      font-size: 24px;
    }

    #noData {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #999;
      font-size: 36px;
    }

    #noData span {
      margin-top: -50px;
    }
  </style>
  <template>
    <div id="loading" hidden$="[[computeHideLoading(data)]]">
      <span>Loading&nbsp;</span>
      <paper-spinner alt="Loading contacts list" active></paper-spinner>
    </div>
    <div id="noData" hidden$="[[computeHideNoData(data)]]"><span>No data</span></div>
    <div id="canvas" hidden$="[[computeHideGraph(data)]]"></div>
  </template>
</dom-module>

<script>

(function() {

  Polymer({
    is: 'twb-chart',

    properties: {
      chart: {
        notify: true
      },
      data: {
        type: Object,
        value: function () {
          return null;
        }
      },
      postUnits: {
        type: String,
        value: ''
      }
    },

    observers: [
      'updateChart(data.*)'
    ],

    behaviors: [
      Polymer.IronResizableBehavior
    ],

    listeners: {
      'iron-resize': 'onIronResize'
    },

    attached: function() {
      this.async(this.notifyResize, 1);
    },

    onIronResize: function() {
      if (this.chart) {
        this.chart.resizeHandler();
      }
    },

    updateChart: function() {
      if (this.data && this.data.length > 0) {
        if (this.chart) {
          if (!_.isEqual(this.oldData, this.data)) {
            this.chart.setData(this.data);
            this.oldData = this.data;
          }
        }
        else {
          this.chart = new Morris.Line({
            element: this.$.canvas,
            data: this.data,
            xkey: 'time',
            ykeys: ['value'],
            labels: ['Value'],
            pointSize: 0,
            gridTextColor: '#fff',
            lineColors: ['#4285f4'],
            postUnits: this.postUnits,
            dateFormat: function (x) { return moment(x).format('LL'); }
          });
          // Force redraw
          this.async(this.onIronResize, 1);
        }
      }
      else if (this.chart) {
        // Nothing todo here : the chart will be hidden
      }
    },

    computeHideLoading: function(data) {
      return this.data !== undefined && this.data !== null;
    },

    computeHideNoData: function(data) {
      return (this.data === undefined || this.data === null) || this.data.length !== 0;
    },

    computeHideGraph: function(data) {
      return (this.data === undefined || this.data === null) || this.data.length === 0;
    },

    arraysEqual: function(a, b) {
      if (a === b) return true;
      if (a == null || b == null) return false;
      if (a.length != b.length) return false;

      // If you don't care about the order of the elements inside
      // the array, you should sort both arrays here.

      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

  });

})();
</script>
